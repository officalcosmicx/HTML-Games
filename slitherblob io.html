<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SlitherBlob.io</title>
<link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;700&display=swap" rel="stylesheet">
<style>
/* General Styling (Kept the same for aesthetics) */
body {
display: flex;
flex-direction: column;
align-items: center;
justify-content: center;
min-height: 100vh;
margin: 0;
background-color: #f0f4f8;
font-family: 'Fredoka', cursive;
color: #333;
padding: 10px;
user-select: none; /* Prevent selection during touch/mouse drag */
}

/* Game Container */
.game-container {
background: linear-gradient(145deg, #ffffff, #e6e6e6);
border-radius: 20px;
box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2), 0 0 0 8px #dce3e9;
padding: 20px;
text-align: center;
max-width: 95%;
position: relative;
}

/* Canvas Styling (The actual game area) */
#gameCanvas {
border: 5px solid #4a90e2;
background-color: #ecf0f1;
box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.1);
border-radius: 10px;
touch-action: none; /* Prevents default browser actions like scrolling */
}

/* Score and Status */
.status-bar {
margin: 15px 0 10px;
display: flex;
justify-content: space-between;
align-items: center;
width: 100%;
max-width: 800px;
}

.score-display, .level-display {
font-size: 1.5rem;
font-weight: 700;
color: #4a90e2;
padding: 8px 15px;
background-color: #fff;
border-radius: 12px;
box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
}

/* Message Box/Game Over Screen */
#messageBox {
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
background: rgba(255, 255, 255, 0.95);
border-radius: 15px;
padding: 30px 40px;
box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
text-align: center;
z-index: 10;
display: none; /* Hidden by default */
}

#messageBox h2 {
color: #e74c3c;
margin-top: 0;
font-size: 2.5rem;
}

#messageBox p {
font-size: 1.2rem;
margin-bottom: 20px;
}

/* Button Styling */
button {
background-color: #2ecc71;
color: white;
border: none;
padding: 12px 25px;
font-size: 1.1rem;
font-weight: 700;
border-radius: 8px;
cursor: pointer;
box-shadow: 0 5px #27ae60;
transition: all 0.1s ease;
}

button:hover {
background-color: #27ae60;
}

button:active {
box-shadow: 0 2px #27ae60;
transform: translateY(3px);
}

/* Controls Hint */
.controls-hint {
margin-top: 15px;
font-size: 0.9rem;
color: #666;
}
</style>
</head>
<body>

<div class="game-container">
<h1>SlitherBlob.io</h1>

<div class="status-bar">
<div class="score-display">Length: <span id="score">0</span></div>
<div class="level-display">Speed: <span id="speed">4</span></div>
</div>

<canvas id="gameCanvas" width="800" height="500"></canvas>

<div id="messageBox">
<h2 id="messageTitle">Game Over!</h2>
<p id="messageText">Your final score is: 0</p>
<button onclick="startGame()">Play Again</button>
</div>

<div class="controls-hint">
Hold **A / ArrowLeft** to turn left. Hold **D / ArrowRight** to turn right.
</div>
</div>

<script>
// === Game Constants (Updated for continuous movement) ===
const CANVAS_WIDTH = 800;
const CANVAS_HEIGHT = 500;
const BLOB_RADIUS = 10; // Radius of each blob segment
let BLOB_SPEED = 4; // Base speed (pixels per frame)
// INCREASED TURN_SPEED from 0.05 to 0.10 for faster turning
const TURN_SPEED = 0.10; // How quickly the blob can rotate (in radians)
const SEGMENT_SPACING = 5; // How far apart the centers of the segments are
const MAX_FOOD_COUNT = 40; // NEW: Maintain 40 food items on the map at all times

// === Game State Variables ===
let canvas, ctx;
let snake = [];
let foods = []; // UPDATED: Food is now an array of objects
let score = 0;
let isPaused = true;
let currentAngle = 0; // The angle the blob is currently moving
let rotationDirection = 0; // -1 for left, 1 for right, 0 for no rotation (maintains angle)

// --- Helper Functions ---

/**
* Clears the canvas for the next frame.
* MOVED TO THE TOP OF HELPER FUNCTIONS TO PREVENT REFERENCE ERROR
*/
function clearCanvas() {
ctx.fillStyle = '#ecf0f1';
ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
}

/**
* Converts RGB color to a hex string.
*/
function rgbToHex(r, g, b) {
return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
}

/**
* Draws one segment of the snake (a rounded blob).
*/
function drawSnakeSegment(segment) {
ctx.fillStyle = segment.color || '#4a90e2';
ctx.beginPath();
ctx.arc(
segment.x,
segment.y,
segment.radius,
0,
2 * Math.PI
);
ctx.fill();
}

/**
* Draws all food items on the map.
*/
function drawFoods() {
for (const food of foods) {
ctx.fillStyle = food.color;
ctx.beginPath();
ctx.arc(
food.x,
food.y,
BLOB_RADIUS * 0.7, // Orbs are slightly smaller
0,
2 * Math.PI
);
ctx.fill();
}
}

/**
* Generates a new food object at a random location and adds it to the foods array.
*/
function createFood() {
let newFoodX, newFoodY, isCollision;
let foodItem;

do {
// Random position using floating point for free roam
newFoodX = Math.random() * (CANVAS_WIDTH - 2 * BLOB_RADIUS) + BLOB_RADIUS;
newFoodY = Math.random() * (CANVAS_HEIGHT - 2 * BLOB_RADIUS) + BLOB_RADIUS;
isCollision = false;

// Simple check: don't spawn right on top of the snake head
const head = snake[0];
const distance = Math.sqrt(Math.pow(head.x - newFoodX, 2) + Math.pow(head.y - newFoodY, 2));
if (distance < head.radius + BLOB_RADIUS * 0.7) {
isCollision = true;
}
} while (isCollision);

const r = Math.floor(Math.random() * 256);
const g = Math.floor(Math.random() * 256);
const b = Math.floor(Math.random() * 256);

foodItem = {
x: newFoodX,
y: newFoodY,
color: rgbToHex(r, g, b)
};

foods.push(foodItem); // Add the newly created food to the array
}

/**
* Normalizes an angle to be within -PI and PI.
*/
function normalizeAngle(angle) {
while (angle > Math.PI) angle -= 2 * Math.PI;
while (angle < -Math.PI) angle += 2 * Math.PI;
return angle;
}

// --- Game Logic ---

/**
* The main game loop function (using requestAnimationFrame for smooth movement).
*/
function gameLoop() {
if (isPaused) {
requestAnimationFrame(gameLoop);
return;
}

// 1. Steering Logic: Apply rotation only if a key is held
if (rotationDirection !== 0) {
// Adjust the current angle based on rotation direction and turn speed
currentAngle += rotationDirection * TURN_SPEED;
currentAngle = normalizeAngle(currentAngle);
}

// 2. Calculate new head position (Continuous movement)
const head = snake[0];
const newHead = {
x: head.x + Math.cos(currentAngle) * BLOB_SPEED,
y: head.y + Math.sin(currentAngle) * BLOB_SPEED,
color: head.color,
radius: head.radius
};

// 3. Check for game over (wall collision or self-collision)
if (checkGameOver(newHead)) {
endGame("Game Over!", `You crashed! Final Length: ${score + 3}`);
return;
}

// 4. Update head position and tail segments
snake.unshift(newHead); // Add the new head

// Tail following: segments lag behind the one in front
for (let i = 1; i < snake.length; i++) {
const prevSegment = snake[i - 1];
const currentSegment = snake[i];

const dx = prevSegment.x - currentSegment.x;
const dy = prevSegment.y - currentSegment.y;
const distance = Math.sqrt(dx * dx + dy * dy);

// If the segment is too far, pull it towards the previous one
if (distance > SEGMENT_SPACING) {
const angle = Math.atan2(dy, dx);
currentSegment.x = prevSegment.x - Math.cos(angle) * SEGMENT_SPACING;
currentSegment.y = prevSegment.y - Math.sin(angle) * SEGMENT_SPACING;
}
}


// 5. Check for food collision (Loop through all food items)
let eatenFoodIndex = -1;

for (let i = 0; i < foods.length; i++) {
const food = foods[i];
const distanceToFood = Math.sqrt(Math.pow(head.x - food.x, 2) + Math.pow(head.y - food.y, 2));

if (distanceToFood < head.radius + BLOB_RADIUS * 0.7) {
eatenFoodIndex = i;
break; // Stop checking after the first collision
}
}

if (eatenFoodIndex !== -1) {
// Food was eaten: Grow the snake
score++;

// Get the color of the food that was just eaten
const foodEaten = foods[eatenFoodIndex];
const lastSegment = snake[snake.length - 1];

// Create a new segment matching the eaten food's color
const newSegment = {
x: lastSegment.x,
y: lastSegment.y,
color: foodEaten.color,
radius: BLOB_RADIUS
};

// Add the new segment
snake.push(newSegment);

document.getElementById('score').textContent = score + 3; // +3 for initial length

// Check for speed increase (level up)
if (score % 10 === 0) {
BLOB_SPEED = Math.min(8, BLOB_SPEED + 0.5); // Max speed of 8
document.getElementById('speed').textContent = BLOB_SPEED;
}

// Remove the eaten food and immediately create a replacement
foods.splice(eatenFoodIndex, 1);
createFood();

} else {
// If no food was eaten, remove the oldest head segment to maintain length
snake.pop();
}

// 6. Draw everything
clearCanvas();
drawFoods(); // UPDATED: Call drawFoods to draw all of them
// Draw segments from tail to head (index 0 is head)
for (let i = snake.length - 1; i >= 0; i--) {
drawSnakeSegment(snake[i]);
}

requestAnimationFrame(gameLoop);
}

/**
* Checks for collision with walls or self.
*/
function checkGameOver(head) {
// Collision with walls (check if head center is outside bounds)
if (head.x < head.radius || head.x > CANVAS_WIDTH - head.radius ||
head.y < head.radius || head.y > CANVAS_HEIGHT - head.radius) {
return true;
}

// Collision with self (head collides with any body segment after the 5th segment)
// Start checking from index 5 to avoid immediate self-collision on tight turns
for (let i = 5; i < snake.length; i++) {
const segment = snake[i];
const distance = Math.sqrt(Math.pow(head.x - segment.x, 2) + Math.pow(head.y - segment.y, 2));
// Collision if distance is less than the sum of radii (plus a small tolerance)
if (distance < head.radius + segment.radius * 0.8) {
return true;
}
}

return false;
}

/**
* Initializes and starts the game.
*/
function startGame() {
// Reset game state
currentAngle = 0; // Start moving right
rotationDirection = 0; // Not rotating initially
BLOB_SPEED = 4;
score = 0;

// Initial snake segments (placed tightly)
snake = [];
for (let i = 0; i < 3; i++) {
snake.push({
x: CANVAS_WIDTH / 2 - i * SEGMENT_SPACING,
y: CANVAS_HEIGHT / 2,
color: i === 0 ? '#4a90e2' : '#68a0f0', // Head is slightly different color
radius: BLOB_RADIUS
});
}

isPaused = false;

// Initialize multiple food items
foods = []; // Clear previous food
for (let i = 0; i < MAX_FOOD_COUNT; i++) {
createFood();
}

document.getElementById('score').textContent = score + 3;
document.getElementById('speed').textContent = BLOB_SPEED;
document.getElementById('messageBox').style.display = 'none';

// Start the game loop using requestAnimationFrame for smoothness
requestAnimationFrame(gameLoop);
}

/**
* Stops the game and shows the message box.
*/
function endGame(title, text) {
isPaused = true;
document.getElementById('messageTitle').textContent = title;
document.getElementById('messageText').textContent = text;
document.getElementById('messageBox').style.display = 'block';
}

// --- Event Listeners (Input Handling) ---

/**
* Handles keyboard input for direction change (WASD and Arrow Keys).
* Pressing 'A'/'Left' starts counter-clockwise rotation (-1).
* Pressing 'D'/'Right' starts clockwise rotation (1).
* W/S/Up/Down are ignored for steering.
*/
function changeDirection(event) {
const key = event.key.toLowerCase();

if (key === 'arrowleft' || key === 'a') {
rotationDirection = -1;
} else if (key === 'arrowright' || key === 'd') {
rotationDirection = 1;
}
}

/**
* Stops rotation when the steering key is released.
*/
function stopRotation(event) {
const key = event.key.toLowerCase();

// Stop rotation only if the released key was the one controlling the current rotation.
if ((key === 'arrowleft' || key === 'a') && rotationDirection === -1) {
rotationDirection = 0;
} else if ((key === 'arrowright' || key === 'd') && rotationDirection === 1) {
rotationDirection = 0;
}
}


// --- Initialization ---

window.onload = function() {
canvas = document.getElementById('gameCanvas');
ctx = canvas.getContext('2d');

// Set canvas size for consistency
canvas.width = CANVAS_WIDTH;
canvas.height = CANVAS_HEIGHT;

document.addEventListener('keydown', changeDirection);
document.addEventListener('keyup', stopRotation);

// Start the game initially paused with a message
endGame("Welcome to SlitherBlob.io!", "Use A/Left to steer left, D/Right to steer right. Release the key to glide! Click 'Play Again' to start!");
};

</script>
</body>
</html>
