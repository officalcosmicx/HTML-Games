<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>PIXEL CHASE | Escape 2D</title>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<style>
/* Base styles for the game (RETRO THEME) */
body {
display: flex;
flex-direction: column;
align-items: center;
justify-content: center;
min-height: 100vh;
margin: 0;
background-color: #1d2b53; /* Dark Retro Blue/Purple */
font-family: 'Press Start 2P', cursive;
color: #fff;
padding: 20px;
box-sizing: border-box;
user-select: none;
}

.game-container {
display: flex;
flex-direction: column;
align-items: center;
width: 100%;
max-width: 500px;
background-color: #000;
border: 8px solid #7e2553; /* Retro border color */
border-radius: 4px;
box-shadow: 0 0 20px #ff004d; /* Bright neon shadow */
}

h1 {
font-size: 1.2rem;
text-align: center;
margin: 15px 0 10px 0;
color: #faef5a; /* Bright Yellow Title */
}

#score-board {
display: flex;
justify-content: space-between;
width: 90%;
margin-bottom: 10px;
padding: 5px 0;
font-size: 0.75rem;
border-bottom: 2px dashed #4b692f;
position: relative; /* For powerup status */
}

#score {
color: #4b692f; /* Dark Green Score */
}
#highScore {
color: #ab5236; /* Orange High Score */
}

#powerup-status {
position: absolute;
top: 0;
left: 50%;
transform: translateX(-50%);
font-size: 0.6rem;
background-color: rgba(0, 0, 0, 0.7);
padding: 2px 8px;
border-radius: 3px;
display: none;
}

canvas {
background-color: #29366f; /* Road/Play Area Color */
touch-action: none;
}

/* --- Modal Styling (General) --- */
.modal-box {
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
background: rgba(0, 0, 0, 0.9);
border: 4px solid #ab5236;
padding: 25px;
border-radius: 8px;
text-align: center;
z-index: 100;
max-width: 90%;
box-shadow: 0 0 25px #ff004d;
line-height: 1.5;
display: none;
flex-direction: column;
align-items: center;
}

.modal-box h2 {
font-size: 1.5rem;
margin-top: 0;
color: #faef5a;
}

.modal-box p {
font-size: 0.6rem;
margin: 10px 0 20px 0;
color: #c0c7c0;
}

.start-button {
background-color: #4b692f;
color: #000;
border: none;
padding: 10px 20px;
text-transform: uppercase;
font-family: 'Press Start 2P', cursive;
cursor: pointer;
border-radius: 5px;
font-size: 0.7rem;
transition: background-color 0.1s, transform 0.1s;
margin: 5px;
}

.start-button:hover {
background-color: #639b36;
}
.start-button:active {
transform: scale(0.95);
}

.button-group {
display: flex;
justify-content: center;
margin-top: 15px;
}

/* --- Customization Menu Specific Styles --- */
#color-options {
display: flex;
flex-wrap: wrap;
justify-content: center;
gap: 10px;
margin-top: 15px;
}

.color-swatch {
width: 40px;
height: 40px;
border-radius: 50%;
cursor: pointer;
border: 4px solid transparent;
box-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
transition: transform 0.1s, border-color 0.2s;
}

.color-swatch:hover {
transform: scale(1.1);
}

.color-swatch.selected {
border-color: #faef5a;
transform: scale(1.1);
}


/* Mobile Controls */
.controls {
display: none;
flex-direction: column;
align-items: center;
margin-top: 20px;
width: 100%;
max-width: 300px;
}

.controls-row {
display: flex;
justify-content: center;
width: 100%;
margin: 5px 0;
}

.control-btn {
background-color: #7e2553;
color: #faef5a;
border: 2px solid #ab5236;
border-radius: 4px;
width: 70px;
height: 35px;
margin: 5px;
font-family: 'Press Start 2P', cursive;
font-size: 0.5rem;
cursor: pointer;
transition: background-color 0.1s;
display: flex;
align-items: center;
justify-content: center;
user-select: none;
box-shadow: 0 2px 0 #4c4c4c;
}
.control-btn:active {
background-color: #9d3f71;
transform: translateY(2px);
box-shadow: none;
}
.control-btn:empty {
visibility: hidden;
}

/* Responsive Adjustments */
@media (max-width: 650px) {
h1 {
font-size: 0.8rem;
}
#score-board {
font-size: 0.6rem;
}
.controls {
display: flex;
}
.modal-box h2 {
font-size: 1.2rem;
}
.modal-box p {
font-size: 0.5rem;
}
.start-button {
font-size: 0.6rem;
padding: 8px 15px;
}
.color-swatch {
width: 30px;
height: 30px;
}
}
</style>
</head>
<body>

<div class="game-container">
<h1>PIXEL CHASE</h1>
<div id="score-board">
<span id="score">TIME: 0.00s</span>
<span id="highScore">HIGH: 0.00s</span>
<span id="powerup-status"></span>
</div>
<canvas id="gameCanvas" width="400" height="400"></canvas>
</div>

<!-- Instructions / Game Over Modal -->
<div id="message-box" class="modal-box">
<h2 id="message-title">GETAWAY!</h2>
<p id="message-content">
Use the **Arrow Keys / W A S D** or **Buttons** to drive.<br>
**Stay alive** and avoid the dark cop cars! Collect the **random power-ups** to help.
</p>
<div class="button-group">
<button class="start-button" id="startButton">START CHASE</button>
<button class="start-button" id="customizeButton">CUSTOMIZE</button>
</div>
</div>

<!-- Customization Modal -->
<div id="customization-box" class="modal-box">
<h2>CUSTOM RIDE</h2>
<p>Choose your getaway car color. It saves automatically!</p>
<div id="color-options">
<!-- Swatches are inserted by JS -->
</div>
<button class="start-button" id="backButton">BACK</button>
</div>

<!-- Mobile Touch Controls -->
<div class="controls">
<div class="controls-row">
<div class="control-btn" data-key="up">UP</div>
</div>
<div class="controls-row">
<div class="control-btn" data-key="left">LEFT</div>
<div class="control-btn" data-key=""></div>
<div class="control-btn" data-key="right">RIGHT</div>
</div>
<div class="controls-row">
<div class="control-btn" data-key="down">DOWN</div>
</div>
</div>

<script>
// --- Firebase/Auth Setup (Mandatory environment variables) ---
const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
const __initial_auth_token = typeof window.__initial_auth_token !== 'undefined' ? window.__initial_auth_token : null;

// This simple static game will use localStorage for high score instead of Firestore
// to minimize complexity and ensure fast loading on limited school networks.

// --- Game Setup ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreDisplay = document.getElementById('score');
const highScoreDisplay = document.getElementById('highScore');
const powerupStatus = document.getElementById('powerup-status');
const messageBox = document.getElementById('message-box');
const customizationBox = document.getElementById('customization-box');
const messageTitle = document.getElementById('message-title');
const messageContent = document.getElementById('message-content');
const startButton = document.getElementById('startButton');
const customizeButton = document.getElementById('customizeButton');
const backButton = document.getElementById('backButton');
const colorOptionsContainer = document.getElementById('color-options');

// Game Constants
const CANVAS_SIZE = 400;
const PLAYER_SIZE = 20;
const COP_SIZE = 20;
const POWERUP_SIZE = 15;
const ROAD_COLOR = '#29366f';
const COP_COLOR = '#4c4c4c'; // Dark Grey for Cops
const COLLISION_COLOR = '#ff004d'; // Bright Red/Pink for crash
const MAX_SPEED = 2.5;
const ROTATION_SPEED = 0.05;

// Power-up definitions
const POWERUP_TYPES = {
BOOST: { color: '#4b692f', duration: 5000, label: 'SPEED BOOST', speedBoost: 1.5, copSlow: 1.0 }, // Green
SLOW: { color: '#00a8a8', duration: 7000, label: 'COP SLOW', speedBoost: 1.0, copSlow: 0.5 } // Cyan/Light Blue
};
const POWERUP_SPAWN_CHANCE = 0.005; // 0.5% chance per frame if none exists

// Customization Options
const CAR_COLORS = {
YELLOW: '#faef5a',
RED: '#e00000',
CYAN: '#00ffff',
PINK: '#ff00ff',
WHITE: '#c0c7c0',
ORANGE: '#ff8800'
};

// Load custom color or default
let savedPlayerColor = localStorage.getItem('pixel_chase_player_color') || CAR_COLORS.YELLOW;
let PLAYER_COLOR = savedPlayerColor;

// Game State
let player = { x: CANVAS_SIZE / 2 - PLAYER_SIZE / 2, y: CANVAS_SIZE / 2 - PLAYER_SIZE / 2, angle: 0, speed: 0 };
let cops = [];
let score = 0;
let isGameOver = true;
let lastUpdateTime = 0;
let copSpawnTimer = 0;
const INITIAL_COP_SPAWN_INTERVAL = 3000; // 3 seconds
let currentCopSpawnInterval = INITIAL_COP_SPAWN_INTERVAL;
let copSpeedMultiplier = 1.0; // Multiplier to slow/speed up cops
let maxPlayerSpeed = MAX_SPEED; // Player speed affected by power-ups

// Power-up State
let powerup = null;
let powerupActive = { type: null, endTime: 0, color: '' }; // Track active power-up details

// Input State
let keys = {};
let inputMagnitude = 0; // 0 to 1 for touch/keyboard acceleration

// Load High Score
let highScore = parseFloat(localStorage.getItem('pixel_chase_high_score')) || 0;
highScoreDisplay.textContent = `HIGH: ${highScore.toFixed(2)}s`;

// --- Customization Functions ---

function setupColorSwatches() {
colorOptionsContainer.innerHTML = '';
for (const key in CAR_COLORS) {
const color = CAR_COLORS[key];
const swatch = document.createElement('div');
swatch.className = 'color-swatch';
swatch.style.backgroundColor = color;
swatch.dataset.color = color;
if (color === PLAYER_COLOR) {
swatch.classList.add('selected');
}

swatch.addEventListener('click', () => {
setPlayerColor(color);
});
colorOptionsContainer.appendChild(swatch);
}
}

function setPlayerColor(color) {
PLAYER_COLOR = color;
localStorage.setItem('pixel_chase_player_color', color);
// Update selected class
document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('selected'));
document.querySelector(`.color-swatch[data-color="${color}"]`).classList.add('selected');
}

function showCustomization() {
messageBox.style.display = 'none';
customizationBox.style.display = 'flex';
setupColorSwatches();
}

function hideCustomization() {
customizationBox.style.display = 'none';
messageBox.style.display = 'flex';
}

// --- Power-up Functions ---

function spawnPowerUp() {
if (powerup) return; // Only one power-up at a time

const typeKeys = Object.keys(POWERUP_TYPES);
const randomType = POWERUP_TYPES[typeKeys[Math.floor(Math.random() * typeKeys.length)]];

let newPowerUp;
do {
newPowerUp = {
x: Math.random() * (CANVAS_SIZE - POWERUP_SIZE),
y: Math.random() * (CANVAS_SIZE - POWERUP_SIZE),
type: randomType,
};
} while (isColliding(newPowerUp.x, newPowerUp.y, POWERUP_SIZE, player));

powerup = newPowerUp;
}

function applyPowerUp(type) {
// Clear existing effect if any
if (powerupActive.type) {
clearPowerUp();
}

powerupActive.type = type.label;
powerupActive.color = type.color;
powerupActive.endTime = performance.now() + type.duration;
powerupStatus.style.display = 'block';

if (type.label === 'SPEED BOOST') {
maxPlayerSpeed = MAX_SPEED * type.speedBoost;
powerupStatus.style.backgroundColor = type.color;
powerupStatus.style.color = '#000';
} else if (type.label === 'COP SLOW') {
copSpeedMultiplier = type.copSlow;
powerupStatus.style.backgroundColor = type.color;
powerupStatus.style.color = '#000';
}

powerup = null; // Consume power-up
}

function clearPowerUp() {
// Reset state to normal
maxPlayerSpeed = MAX_SPEED;
copSpeedMultiplier = 1.0;
powerupActive = { type: null, endTime: 0, color: '' };
powerupStatus.style.display = 'none';
}

// --- Game Logic Functions ---

function initGame() {
// Reset state
player = { x: CANVAS_SIZE / 2 - PLAYER_SIZE / 2, y: CANVAS_SIZE / 2 - PLAYER_SIZE / 2, angle: 0, speed: 0 };
cops = [];
score = 0;
isGameOver = false;
lastUpdateTime = performance.now();
copSpawnTimer = 0;
currentCopSpawnInterval = INITIAL_COP_SPAWN_INTERVAL;
copSpeedMultiplier = 1.0;
maxPlayerSpeed = MAX_SPEED;
powerup = null;
clearPowerUp();

scoreDisplay.textContent = `TIME: 0.00s`;
messageBox.style.display = 'none';
customizationBox.style.display = 'none';

// Start game loop
requestAnimationFrame(gameLoop);
}

function spawnCop() {
const side = Math.floor(Math.random() * 4); // 0=Top, 1=Right, 2=Bottom, 3=Left
let copX, copY;

// Spawn outside the canvas
const OFFSET = 50;

switch (side) {
case 0: copX = Math.random() * CANVAS_SIZE; copY = -OFFSET; break;
case 1: copX = CANVAS_SIZE + OFFSET; copY = Math.random() * CANVAS_SIZE; break;
case 2: copX = Math.random() * CANVAS_SIZE; copY = CANVAS_SIZE + OFFSET; break;
case 3: copX = -OFFSET; copY = Math.random() * CANVAS_SIZE; break;
}

cops.push({
x: copX,
y: copY,
angle: 0,
// Base speed is slightly faster than player MAX_SPEED
baseSpeed: 1.0 + Math.random() * 0.5,
color: COP_COLOR
});
}

function isColliding(x1, y1, s1, target) {
// Simple AABB collision check
return x1 < target.x + PLAYER_SIZE &&
x1 + s1 > target.x &&
y1 < target.y + PLAYER_SIZE &&
y1 + s1 > target.y;
}

function update(deltaTime) {
const now = performance.now();

// 1. Update Score
score += deltaTime / 1000;
scoreDisplay.textContent = `TIME: ${score.toFixed(2)}s`;

// 2. Handle Player Input
let turning = 0;
if (keys['ArrowLeft'] || keys['a']) turning = -1;
if (keys['ArrowRight'] || keys['d']) turning = 1;

// Acceleration/Deceleration
if (keys['ArrowUp'] || keys['w'] || keys['ArrowDown'] || keys['s'] || inputMagnitude > 0) {
// Accelerate up to maxPlayerSpeed
player.speed = Math.min(player.speed + 0.1, maxPlayerSpeed);
} else {
// Decelerate naturally
player.speed = Math.max(player.speed - 0.05, 0);
}

// Apply rotation and movement
player.angle += turning * ROTATION_SPEED * (deltaTime / 16.67);

const velocityX = Math.cos(player.angle) * player.speed;
const velocityY = Math.sin(player.angle) * player.speed;

player.x += velocityX;
player.y += velocityY;

// 3. Keep Player on Screen (wrapping)
if (player.x < -PLAYER_SIZE) player.x = CANVAS_SIZE;
if (player.x > CANVAS_SIZE) player.x = -PLAYER_SIZE;
if (player.y < -PLAYER_SIZE) player.y = CANVAS_SIZE;
if (player.y > CANVAS_SIZE) player.y = -PLAYER_SIZE;

// 4. Power-up Logic
if (powerup) {
// Check for power-up collision
if (isColliding(powerup.x, powerup.y, POWERUP_SIZE, player)) {
applyPowerUp(powerup.type);
}
} else if (Math.random() < POWERUP_SPAWN_CHANCE) {
// Try to spawn a new power-up
spawnPowerUp();
}

if (powerupActive.type) {
const remainingTime = Math.max(0, powerupActive.endTime - now);
powerupStatus.textContent = `${powerupActive.type}: ${(remainingTime / 1000).toFixed(1)}s`;
if (remainingTime === 0) {
clearPowerUp();
}
}

// 5. Update Cops
cops = cops.filter(cop => {
const targetX = player.x + PLAYER_SIZE / 2;
const targetY = player.y + PLAYER_SIZE / 2;

const angleToPlayer = Math.atan2(targetY - (cop.y + COP_SIZE / 2), targetX - (cop.x + COP_SIZE / 2));

// Cops turn slowly towards the player
cop.angle = angleToPlayer; // Instantaneous turning for simplicity

// Move the cop, applying the global speed multiplier
const effectiveSpeed = cop.baseSpeed * copSpeedMultiplier;
cop.x += Math.cos(cop.angle) * effectiveSpeed;
cop.y += Math.sin(cop.angle) * effectiveSpeed;

// Check for collision with player
if (isColliding(player.x, player.y, PLAYER_SIZE, cop)) {
gameOver();
}

// Remove cops that are too far away
const distanceSq = (cop.x - player.x) ** 2 + (cop.y - player.y) ** 2;
return distanceSq < (CANVAS_SIZE * 2) ** 2;

});

// 6. Spawn New Cops
copSpawnTimer += deltaTime;
if (copSpawnTimer >= currentCopSpawnInterval) {
spawnCop();
copSpawnTimer = 0;
// Difficulty increases by decreasing spawn interval
currentCopSpawnInterval = Math.max(500, currentCopSpawnInterval - 50);
}
}

// Draw the retro 2D world
function draw() {
ctx.fillStyle = ROAD_COLOR;
ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

// Draw center point / road markings (retro style)
ctx.fillStyle = '#c0c7c0';
for (let i = 0; i < CANVAS_SIZE; i += 40) {
for (let j = 0; j < CANVAS_SIZE; j += 40) {
ctx.fillRect(i, j, 5, 5);
}
}

// Draw Power-up
if (powerup) {
ctx.fillStyle = powerup.type.color;
ctx.fillRect(powerup.x, powerup.y, POWERUP_SIZE, POWERUP_SIZE);

// Draw a letter on the power-up
ctx.font = '8px "Press Start 2P"';
ctx.fillStyle = '#000';
ctx.textAlign = 'center';
ctx.textBaseline = 'middle';
const text = powerup.type.label === 'SPEED BOOST' ? 'S' : 'L';
ctx.fillText(text, powerup.x + POWERUP_SIZE / 2, powerup.y + POWERUP_SIZE / 2 + 1);
}

// Draw Player Car
drawCar(player, PLAYER_SIZE, PLAYER_COLOR, '#c0c7c0');

// Draw Cop Cars
cops.forEach(cop => {
// Flashy red/blue lights on the cops
const lightColor = (Math.floor(Date.now() / 200) % 2 === 0) ? '#0070a8' : '#e00000';
drawCar(cop, COP_SIZE, cop.color, lightColor);
});
}

function drawCar(car, size, bodyColor, lightColor) {
// Save the current state of the canvas
ctx.save();

// Translate to the center of the car and rotate
ctx.translate(car.x + size / 2, car.y + size / 2);
ctx.rotate(car.angle);

// 1. Draw Body
ctx.fillStyle = bodyColor;
ctx.fillRect(-size / 2, -size / 2, size, size);

// 2. Draw Windshield (front indicator)
ctx.fillStyle = '#000';
ctx.fillRect(-size / 2, -size / 2 + 2, size / 2, size - 4);

// 3. Draw Lights/Detail (top)
ctx.fillStyle = lightColor;
ctx.fillRect(-size / 2 + size * 0.75, -size / 2, size * 0.25, size); // Rear bumper/light

// Restore the canvas state
ctx.restore();
}

function gameLoop(currentTime) {
if (isGameOver) return;

const deltaTime = currentTime - lastUpdateTime;
lastUpdateTime = currentTime;

update(deltaTime);
draw();

requestAnimationFrame(gameLoop);
}

function gameOver() {
isGameOver = true;
clearPowerUp(); // Clear any active effects

// Check for high score
if (score > highScore) {
highScore = score;
localStorage.setItem('pixel_chase_high_score', highScore.toFixed(2));
highScoreDisplay.textContent = `HIGH: ${highScore.toFixed(2)}s`;
messageTitle.textContent = "NEW HIGH SCORE!";
} else {
messageTitle.textContent = "BUSTED!";
}

// Show Game Over message
messageContent.innerHTML = `Time Survived: **${score.toFixed(2)}s**<br>They got you! Press the button or **SPACE** to try again.`;
startButton.textContent = "RESTART";
messageBox.style.display = 'flex';

// Draw crash state
draw();
ctx.fillStyle = COLLISION_COLOR;
ctx.fillRect(player.x, player.y, PLAYER_SIZE, PLAYER_SIZE);
}

// --- Event Listeners ---

// Keyboard listeners
document.addEventListener('keydown', e => {
if (isGameOver && (e.key === ' ' || e.key === 'Spacebar')) {
initGame();
e.preventDefault();
return;
}
if (['ArrowUp', 'w', 'ArrowDown', 's', 'ArrowLeft', 'a', 'ArrowRight', 'd'].includes(e.key.toLowerCase())) {
keys[e.key.toLowerCase()] = true;
e.preventDefault();
}
});

document.addEventListener('keyup', e => {
if (['ArrowUp', 'w', 'ArrowDown', 's', 'ArrowLeft', 'a', 'ArrowRight', 'd'].includes(e.key.toLowerCase())) {
keys[e.key.toLowerCase()] = false;
}
});

// UI Button Listeners
startButton.addEventListener('click', initGame);
customizeButton.addEventListener('click', showCustomization);
backButton.addEventListener('click', hideCustomization);

// Mobile Controls (Buttons)
document.querySelectorAll('.control-btn').forEach(btn => {
btn.addEventListener('touchstart', (e) => {
e.preventDefault();
const keyMap = { 'up': 'w', 'down': 's', 'left': 'a', 'right': 'd' };
const key = keyMap[e.currentTarget.dataset.key];
if (key) {
keys[key] = true;
// Only start acceleration if Up/Down is pressed
if (key === 'w' || key === 's') inputMagnitude = 1;
}
if (isGameOver) initGame();
}, { passive: false });

btn.addEventListener('touchend', (e) => {
const keyMap = { 'up': 'w', 'down': 's', 'left': 'a', 'right': 'd' };
const key = keyMap[e.currentTarget.dataset.key];
if (key) {
keys[key] = false;
if (key === 'w' || key === 's') {
// Reset input magnitude only if acceleration keys are released
if (!keys['w'] && !keys['s']) {
inputMagnitude = 0;
}
}
}
});
});

// --- Initialization ---

window.onload = function() {
canvas.width = CANVAS_SIZE;
canvas.height = CANVAS_SIZE;
draw();
messageBox.style.display = 'flex';
setupColorSwatches();
}
</script>
</body>
</html>